#!/bin/bash
# James W. Barnett

# Takes snapshots of each snapper configuration. It then sends the snapshot to
# a location on an external drive. After the initial transfer, it does
# incremental snapshots on later calls. It's important not to delete the
# snapshot created on your system since that will be used to determine the
# difference for the next incremental snapshot.

# Can set the backup directory here, or in the snapper configuration file with
# EXT_BACKUP_LOCATION
declare -r description="latest incremental backup"

# You can set a snapper configuration to be excluded by setting EXT_BACKUP="no"
# in its snapper configuration file.

#--------------------------------------------------------
# Don't modify anything below here

set -e

if [[ $EUID -ne 0 ]]; then
    echo "Script must be run as root." 
    exit
fi

# It's important not to change this userdata in the snapshots, since that's how
# we find the previous one.

TARGETS="$(findmnt -n -v -t btrfs -o TARGET --list)"
declare -a UUIDS
UUIDS="$(findmnt -n -v -t btrfs -o UUID --list)"
menu=0

declare -a TARGETS_ARRAY
declare -a UUIDS_ARRAY

i=0
for x in $TARGETS; do
    TARGETS_ARRAY[$i]=$x
    i=$(($i+1))
done
i=0
for x in $UUIDS; do
    UUIDS_ARRAY[$i]=$x
    i=$(($i+1))
done
total_mounted=$i
echo "The following mounted BTRFS devices were found."
disk=0
while [[ $disk < 1 || $disk > $i ]]; do
    for x in ${!TARGETS_ARRAY[@]}; do
        echo -e "$(($x+1))) ${UUIDS_ARRAY[$x]}\t(${TARGETS_ARRAY[$x]})"
    done
    read -p "Select one: " disk
done
selected_uuid="${UUIDS_ARRAY[$(($disk-1))]}"
echo "You selected the disk with UUID $selected_uuid."

if [[ -f /etc/conf.d/snapper ]]; then
    source /etc/conf.d/snapper 
else
    echo "ERROR: /etc/conf.d/snapper does not exist!"
    exit 1
fi

echo "Performing backup..."

for x in $SNAPPER_CONFIGS; do

    # shellcheck source=/dev/null
    source /etc/snapper/configs/$x


    old_number=$(snapper -c "$x" list -t single | awk '/'"$selected_uuid"'/ {print $1}')
    new_number=$(snapper -c "$x" create --print-number)
    sync
    
    new_snapshot=$SUBVOLUME/.snapshots/$new_number/snapshot
    new_info=$SUBVOLUME/.snapshots/$new_number/info.xml
    echo "At '$x' configuration"

    if [[ -z "$old_number" ]]; then

        echo "No backups have been performed for '$x' on this disk."
        read -p "Enter name of directory to store backups: " mybackupdir

        BACKUPDIR="$(findmnt -n -v -t btrfs -o UUID,TARGET --list | awk '/'$selected_uuid'/ {print $2}')/$mybackupdir"
        backup_location=$BACKUPDIR/$x/$new_number/
        echo "Backup location: $backup_location"
        read -n 1 -p "Continue (y/n)? " cont_backup
        echo
        if [[ "$cont_backup" != "y" ]]; then
            continue
        fi
        mkdir -p "$backup_location"
        echo "Performing initial backup for snapper configuration '$x'. This could take awhile..."
        btrfs send "$new_snapshot" | btrfs receive "$backup_location"

    else

        mybackupdir=$(snapper -c root list -t single | awk -F"|" '/'$selected_uuid'/ {print $5}' | awk -F "," '{print $1}' | awk -F"=" '{print $2}')
        BACKUPDIR="$(findmnt -n -v -t btrfs -o UUID,TARGET --list | awk '/'$selected_uuid'/ {print $2}')/$mybackupdir"

        if [[ ! -d $BACKUPDIR ]]; then
            echo "ERROR: $BACKUPDIR is not a directory."
            exit 1
        fi

        backup_location=$BACKUPDIR/$x/$new_number/

        echo "Backup location: $backup_location"
        if [[ -d "$backup_location" ]]; then
            echo "ERROR: Backup location already exists."
            break
        fi
        mkdir -p "$backup_location"

        read -n 1 -p "Continue (y/n)? " cont_backup
        echo
        if [[ "$cont_backup" != "y" ]]; then
            continue
        fi

        old_snapshot=$SUBVOLUME/.snapshots/$old_number/snapshot

        # Sends the difference between the new snapshot and old snapshot to
        # the backup location. Using the -c flag instead of -p tells it that
        # there is an identical subvolume to the old snapshot at the
        # receiving location where it can get its data. This helps speed up
        # the transfer.
        btrfs send "$new_snapshot" -c "$old_snapshot" | btrfs receive "$backup_location" &>/dev/null

        cp "$new_info" "$backup_location"
        snapper -c "$x" delete "$old_number"

    fi

    userdata="backupdir=$mybackupdir, uuid=$selected_uuid"

    # Tag new snapshot as the latest
    snapper -v -c "$x" modify -d "$description" -u "$userdata" "$new_number"

done

date > "$HOME"/.lastbackup

echo "Done!"
